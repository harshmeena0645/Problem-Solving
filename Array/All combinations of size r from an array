All combinations of size r from an array
Last Updated : 20 May, 2025
You are given an array arr[] consisting of n elements. Your task is to generate and print all possible combinations of exactly r elements from this array.
Note: A combination is a selection of items where the order does not matter. Ensure that each unique group of r elements is printed only once, regardless of order.

Example:

Input: arr = [1, 2, 3, 4], r = 2
Output: 1 2
               1 3
               1 4
               2 3
               2 4
               3 4
Explanation: We need to generate all possible combinations of size 2 from an array of size 4. The total number of such combinations is given by the formula:
4C2 = 4! / [(4 - 2)! × 2!] = 6 combinations.

Input: arr = [1, 2, 3, 4], r = 3
Output: 1 2 3
               1 2 4
               1 3 4
               2 3 4
Explanation: We need to generate all possible combinations of size 3 from an array of size 4. The total number of such combinations is given by the formula:
4C3 = 4! / [(4 - 3)! × 3!] = 4 combinations.


def combinationUtil(ind, r, data, result, arr):
    n = len(arr)

    # If size of current combination is r
    if len(data) == r:
        result.append(data.copy())
        return

    # Replace index with all possible elements
    for i in range(ind, n):

        # Current element is included
        data.append(arr[i])

        # Recur for next elements
        combinationUtil(i + 1, r, data, result, arr)

        # Backtrack to find other combinations
        data.pop()

# Function to find all combinations of size r
# in an array of size n
def findCombination(arr, r):
    n = len(arr)

    # to store the result
    result = []

    # Temporary array to store current combination
    data = []
    combinationUtil(0, r, data, result, arr)
    return result

arr = [1, 2, 3, 4]
r = 2
res = findCombination(arr, r)
for comb in res:
    for num in comb:
        print(num, end=" ")
    print()


Output
1 2 
1 3 
1 4 
2 3 
2 4 
3 4 
Time Complexity: O(r × C(n, r)), generates all combinations of size r from n elements, which is C(n, r) in total.
Each combination takes O(r) time to construct and store, leading to an overall complexity of O(r × C(n, r)).
Auxiliary Space: O(r), recursion depth reaches up to r, so the maximum stack space used is O(r). We are not including the space used for storing the final combinations
