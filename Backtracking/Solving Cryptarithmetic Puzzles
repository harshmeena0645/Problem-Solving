Solving Cryptarithmetic Puzzles

Newspapers and magazines often have crypt-arithmetic puzzles of the form:

   SEND
+ MORE
--------
 MONEY
-------- 

Where the goal is to assign each letter a digit from 0 to 9 so that the arithmetic works out correctly. The rules are that all occurrences of a letter must be assigned the same digit, and no digit can be assigned to more than one letter. You are given three strings a, b, and sum, representing the crypt-arithmetic puzzles, your task is to solve the puzzle and print the three strings representing its solution.

Note: If no possible solution exists, print "-1". If multiple solutions exist, print any.

Example:

Input: a = "send", b = "more", sum = "money"
Output: 7531 0825 08356
Explanation: 7531 + 0825 = 08356, and all the unique characters are assigned unique digits. 2817, 0368, 03185, is also the possible answer.

Input: a = "s", b = "p", sum = "f"
Output: 2 1 3


def solvePuzzleHelper(a, b, sumStr, pos, carry, charToDigit, usedDigits):
    if pos >= len(sumStr):
        return carry == 0

    sumVal = carry
    if pos < len(a) and a[-(pos + 1)] in charToDigit:
        sumVal += charToDigit[a[-(pos + 1)]]
    if pos < len(b) and b[-(pos + 1)] in charToDigit:
        sumVal += charToDigit[b[-(pos + 1)]]

    sumChar = sumStr[-(pos + 1)]

    if sumChar in charToDigit:
        if charToDigit[sumChar] != sumVal % 10:
            return False
        return solvePuzzleHelper(a, b, sumStr, pos + 1, sumVal // 10, charToDigit, usedDigits)

    for digit in range(10):
        if not usedDigits[digit]:
            # Prevent leading zero
            if digit == 0 and sumChar in firstLetters:
                continue
            charToDigit[sumChar] = digit
            usedDigits[digit] = True
            if solvePuzzleHelper(a, b, sumStr, pos + 1, sumVal // 10, charToDigit, usedDigits):
                return True
            del charToDigit[sumChar]
            usedDigits[digit] = False
    return False

def assignDigits(a, b, sumStr, index, order, charToDigit, usedDigits):
    if index == len(order):
        return solvePuzzleHelper(a, b, sumStr, 0, 0, charToDigit, usedDigits)

    ch = order[index]
    for digit in range(10):
        if not usedDigits[digit]:
            if digit == 0 and ch in firstLetters:
                continue
            charToDigit[ch] = digit
            usedDigits[digit] = True
            if assignDigits(a, b, sumStr, index + 1, order, charToDigit, usedDigits):
                return True
            del charToDigit[ch]
            usedDigits[digit] = False
    return False

def solvePuzzle(a, b, sumStr):
    global firstLetters
    charToDigit = {}
    usedDigits = [False] * 10
    uniqueChars = set()
    order = ""
    firstLetters = {a[0], b[0], sumStr[0]}  # no leading zero

    for ch in a + b + sumStr:
        if ch not in uniqueChars:
            uniqueChars.add(ch)
            order += ch

    if len(order) > 10:
        return ["-1"]  # more than 10 unique letters

    if assignDigits(a, b, sumStr, 0, order, charToDigit, usedDigits):
        x = "".join(str(charToDigit[ch]) for ch in a)
        y = "".join(str(charToDigit[ch]) for ch in b)
        z = "".join(str(charToDigit[ch]) for ch in sumStr)
        return [x, y, z]
    return ["-1"]

# Example Test Cases
print(" ".join(solvePuzzle("send", "more", "money")))  # Example: 9567 1085 10652
print(" ".join(solvePuzzle("s", "p", "f")))             # Example: 2 1 3 (or other valid mappings)



âœ… Time Complexity
Let:

n = number of unique letters (at most 10).

k = number of digits to assign = n.

We try all k! (factorial) digit assignments.

So the worst-case time complexity is:

ðŸ‘‰ O(k!) = O(10!) = 3,628,800 (maximum 10 unique letters)
âŒ› Additional Cost:
For each permutation:

We do a linear check of addition â†’ O(L) where L = max(len(a), len(b), len(sum)).

So full complexity:

âœ… Final Complexity:
O(k! Ã— L)
â†’ At worst: O(10! Ã— L) â†’ practically fast for puzzles with â‰¤10 letters.

âœ… Space Complexity:
O(k) for the charToDigit map.

O(10) for usedDigits boolean array.

O(L) for recursive call stack in worst case.

Space: O(k + L)
