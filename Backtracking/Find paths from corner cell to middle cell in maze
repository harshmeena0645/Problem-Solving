Find paths from corner cell to middle cell in maze

Given a square maze represented by a matrix mat[][] of positive numbers, the task is to find all paths from all four corner cells to the middle cell. From any cell mat[i][j] with value n, you are allowed to move exactly n steps in one of the four cardinal directionsâ€”North, South, East, or West. That is, you can move to mat[i + n][j], mat[i - n][j], mat[i][j + n], or mat[i][j - n].

Examples:

Input: mat[][] = [ [ 3, 5, 4, 4, 7, 3, 4, 6, 3 ]
                              [ 6, 7, 5, 6, 6, 2, 6, 6, 2 ]
                              [ 3, 3, 4, 3, 2, 5, 4, 7, 2 ]
                              [ 6, 5, 5, 1, 2, 3, 6, 5, 6 ]
                              [ 3, 3, 4, 3, 0, 1, 4, 3, 4 ]
                              [ 3, 5, 4, 3, 2, 2, 3, 3, 5 ]
                              [ 3, 5, 4, 3, 2, 6, 4, 4, 3 ]
                              [ 3, 5, 1, 3, 7, 5, 3, 6, 4 ]
                              [ 6, 2, 4, 3, 4, 5, 4, 5, 1 ] ]
Output: (0, 0)  (0, 3) (0, 7)  (6, 7) (6, 3) (3, 3) (3, 4) (5, 4) (5, 2) (1, 2) (1, 7) (7, 7) (7, 1) (2, 1) (2, 4) (4, 4)
Explanation: There is one path from top left to the mid (4, 4). Below is given the step-by-step moves to reach the mid cell from top-left cell:
From (0, 0) the cell value is 3, so we move 3 steps to the right, reaching (0, 3).
From (0, 3) the cell value is 4, so we move 4 steps to the right, reaching (0, 7).
From (0, 7) the cell value is 6, so we move 6 steps down, reaching (6, 7).
In the same way, we move remaining cells of the output (6, 7) - > (6, 3) - > (3, 3) -> (3, 4) -> (5, 4) -> (5, 2) -> (1, 2) -> (1, 7) -> (7, 7) -> (7, 1) -> (2, 1) -> (2, 4) -> (4, 4)

Using Backtracking - (4 ^ (n ^ 2)) Time and O(n ^ 2) Space



mod = 1000000007

# function to find a path from source to destination
def findPath(x, y, path, visited, res, mat):
    n = len(mat)

    # if (x, y) is out of bounds
    if x < 0 or x >= n or y < 0 or y >= n:
        return

    # if (x, y) is already visited
    if visited[x][y]:
        return

    # mark (x, y) as visited
    visited[x][y] = 1

    # add (x, y) to path
    path.append([x, y])

    # if (x, y) is the mid cell
    if x == n // 2 and y == n // 2:
        res.append(path.copy())
        path.pop()
        visited[x][y] = 0
        return

    # search in all four directions
    dir = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    for i in range(4):
        u = x + dir[i][0] * mat[x][y]
        v = y + dir[i][1] * mat[x][y]
        findPath(u, v, path, visited, res, mat)

    # backtrack
    path.pop()
    visited[x][y] = 0

# Function to find a path from corner cell to
# middle cell in mat containing positive numbers
def findPathInMaze(mat):
    n = len(mat)

    # to store complete path
    # from source to destination
    res = []

    # to mark visited cells
    visited = [[0 for _ in range(n)] for _ in range(n)]

    # corner cells
    corners = [[0, 0], [0, n - 1], [n - 1, 0], [n - 1, n - 1]]

    # to store the path
    path = []

    # Consider each corners as the starting
    # point and search in mat
    for corner in corners:
        x = corner[0]
        y = corner[1]
        findPath(x, y, path, visited, res, mat)

    return res

if __name__ == "__main__":
    mat = [
        [3, 5, 4, 4, 7, 3, 4, 6, 3],
        [6, 7, 5, 6, 6, 2, 6, 6, 2],
        [3, 3, 4, 3, 2, 5, 4, 7, 2],
        [6, 5, 5, 1, 2, 3, 6, 5, 6],
        [3, 3, 4, 3, 0, 1, 4, 3, 4],
        [3, 5, 4, 3, 2, 2, 3, 3, 5],
        [3, 5, 4, 3, 2, 6, 4, 4, 3],
        [3, 5, 1, 3, 7, 5, 3, 6, 4],
        [6, 2, 4, 3, 4, 5, 4, 5, 1]
    ]
    ans = findPathInMaze(mat)
    for path in ans:
        for cell in path:
            print("({0}, {1}) ".format(cell[0], cell[1]), end="")
        print()
