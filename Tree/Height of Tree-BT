Height of Tree-BT
//1 based indexing

Binary Tree - Analyzing Tournament Levels in a Cricket Championship


In a cricket tournament, the organizer arranges matches in a hierarchy where each level represents a match round. The matches form a binary tree, where the root is the first match of the tournament, and each child node represents subsequent matches. The maximum depth of the tournament structure represents the maximum number of rounds a team has to win to become the champion.

Given the structure of the tournament in the form of a binary tree, find the maximum number of rounds (or depth) of the tournament.

Input Format

First line contains the number of nodes (matches).
The next line contains the values of nodes (matches) in level-order (use "null" for no match at that position).
Constraints

NA

Output Format

A single integer representing the maximum depth of the tournament structure (binary tree).

Sample Input 0

7
3 9 20 null null 15 7
Sample Output 0

3
Explanation 0

The first value 3 is the root of the binary tree (the first match).
The second and third values 9 and 20 represent the left and right matches of 3.
The values null indicate that node 9 has no children.
The next two values 15 and 7 represent the left and right matches of node 20.
The structure of the binary tree looks like this:

  3

 / \

 9 20

   / \

  15  7
The maximum depth of this binary tree is 3 because the longest path from the root 3 to the farthest leaf nodes (15 or 7) contains 3 nodes.

Sample Input 1

7
1 2 3 null null 4 5
Sample Output 1
3



class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.data = key

def build_tree(values):
    if not values or values[0] == "null":
        return None

    root = Node(int(values[0]))
    queue = [root]
    i = 1

    while i < len(values):
        current = queue.pop(0)

        if i < len(values) and values[i] != "null":
            current.left = Node(int(values[i]))
            queue.append(current.left)
        i += 1

        if i < len(values) and values[i] != "null":
            current.right = Node(int(values[i]))
            queue.append(current.right)
        i += 1

    return root

def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

n = int(input())
values = input().split()
root = build_tree(values)
print(max_depth(root))




def tree_height(values):
    values = [v for v in values if v != "null"]
    l = len(values)
    if l == 0:
        return 0
    if l == 1:
        return 1
    i = 1
    while (2**i - 1) < l:
        i += 1
    return i

n = int(input())  
values = input().split()  
print(tree_height(values))
