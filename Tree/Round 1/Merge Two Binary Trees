Merge Two Binary Trees

Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]

Input: root1 = [1], root2 = [1,2]
Output: [2,2]





class Node:
    def __init__(self,data,left=None,right=None):
        self.data=data
        self.left=left
        self.right=right
        
class Solution:
    def mergeTrees(self, t1, t2):
        if t1 and t2:
            root = Node(t1.data + t2.data)
            root.left = self.mergeTrees(t1.left, t2.left)
            root.right = self.mergeTrees(t1.right, t2.right)
            return root
        else:
            return t1 or t2

def create_tree(values):
    if not values or values[0] is None:
        return None
    root=Node(values[0])
    queue=[root]
    i=1
    while queue and i<len(values):
        key=queue.pop(0)
        if i<len(values) and values[i] is not None:
            key.left=Node(values[i])
            queue.append(key.left)
        i+=1
        if i<len(values) and values[i] is not None:
            key.right=Node(values[i])
            queue.append(key.right)
        i+=1
    return root

def level_Traversel(root):
    def bfs(key):
        if not key:
            return
        res.append([k.data for k in key])
        next_level=[]
        for k in key:
            if k.left:
                next_level.append(k.left)
            if k.right:
                next_level.append(k.right)
        bfs(next_level)
    res=[]
    bfs([root] if root else [])
    return res
    
v1 = [1,3,2,5]
v2 = [2,1,3,"null",4,"null",7]
v1 = [None if v == "null" else v for v in v1]
v2 = [None if v == "null" else v for v in v2]
root1 = create_tree(v1)
root2 = create_tree(v2)
sol = Solution()
root=sol.mergeTrees(root1,root2)
print(level_Traversel(root))
